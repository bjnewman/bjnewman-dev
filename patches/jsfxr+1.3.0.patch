diff --git a/node_modules/jsfxr/riffwave.js b/node_modules/jsfxr/riffwave.js
index 54dfaee..37df6f0 100644
--- a/node_modules/jsfxr/riffwave.js
+++ b/node_modules/jsfxr/riffwave.js
@@ -32,6 +32,7 @@ var FastBase64 = {
     var len = src.length;
     var dst = '';
     var i = 0;
+    var n;
     while (len > 2) {
       n = (src[i] << 16) | (src[i+1]<<8) | src[i+2];
       dst+= this.encLookup[n >> 12] + this.encLookup[n & 0xFFF];
@@ -130,23 +131,34 @@ var RIFFWAVE = function(data) {
 }; // end RIFFWAVE
 
 (function (root, factory) {
+  // Handle ESM where 'this' is undefined
+  var globalRoot = root || (typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {}));
   if(typeof define === "function" && define.amd) {
     // Now we're wrapping the factory and assigning the return
     // value to the root (window) and returning it as well to
     // the AMD loader.
     define([], function(){
-      return (root.RIFFWAVE = factory());
+      return (globalRoot.RIFFWAVE = factory());
     });
   } else if(typeof module === "object" && module.exports) {
     // I've not encountered a need for this yet, since I haven't
     // run into a scenario where plain modules depend on CommonJS
     // *and* I happen to be loading in a CJS browser environment
     // but I'm including it for the sake of being thorough
-    module.exports = (root.RIFFWAVE = factory());
+    module.exports = (globalRoot.RIFFWAVE = factory());
   } else {
-    root.RIFFWAVE = factory();
+    globalRoot.RIFFWAVE = factory();
   }
 }(this, function() {
   // module code here....
   return RIFFWAVE;
 }));
+
+// Ensure RIFFWAVE is available globally for ESM bundlers (Vite/esbuild)
+// The UMD wrapper may set it on 'exports' instead of globalThis
+if (typeof globalThis !== 'undefined' && !globalThis.RIFFWAVE) {
+  globalThis.RIFFWAVE = RIFFWAVE;
+}
+if (typeof window !== 'undefined' && !window.RIFFWAVE) {
+  window.RIFFWAVE = RIFFWAVE;
+}
diff --git a/node_modules/jsfxr/riffwave.mjs b/node_modules/jsfxr/riffwave.mjs
new file mode 100644
index 0000000..2d2931e
--- /dev/null
+++ b/node_modules/jsfxr/riffwave.mjs
@@ -0,0 +1,10 @@
+// ESM wrapper for riffwave.js
+// This file provides ES module exports while maintaining backwards compatibility
+// with CommonJS consumers who use the original .js file.
+
+// Import the UMD module - bundlers like Vite/esbuild will convert the
+// module.exports to a default export
+import RIFFWAVE from './riffwave.js';
+
+export { RIFFWAVE };
+export default RIFFWAVE;
diff --git a/node_modules/jsfxr/sfxr.js b/node_modules/jsfxr/sfxr.js
index 4edbbf1..9641b79 100644
--- a/node_modules/jsfxr/sfxr.js
+++ b/node_modules/jsfxr/sfxr.js
@@ -9,6 +9,9 @@ var masterVolume = 1;
 
 var OVERSAMPLING = 8;
 
+// Declare sfxr in module scope for ESM strict mode compatibility
+var sfxr;
+
 /*** Core data structure ***/
 
 // Sound generation parameters are on [0,1] unless noted SIGNED & thus
@@ -1086,22 +1089,24 @@ var units = {
 /*** Plumbing ***/
 
 (function (root, factory) {
+  // Handle ESM where 'this' is undefined
+  var globalRoot = root || (typeof globalThis !== 'undefined' ? globalThis : (typeof window !== 'undefined' ? window : {}));
   if(typeof define === "function" && define.amd) {
     // Now we're wrapping the factory and assigning the return
     // value to the root (window) and returning it as well to
     // the AMD loader.
     define(["./riffwave"], function(RIFFWAVE){
-      return (root.jsfxr = factory(RIFFWAVE));
+      return (globalRoot.jsfxr = factory(RIFFWAVE));
     });
   } else if(typeof module === "object" && module.exports) {
     // I've not encountered a need for this yet, since I haven't
     // run into a scenario where plain modules depend on CommonJS
     // *and* I happen to be loading in a CJS browser environment
     // but I'm including it for the sake of being thorough
-    RIFFWAVE = require("./riffwave.js");
-    module.exports = (root.jsfxr = factory(RIFFWAVE));
+    var RIFFWAVE = require("./riffwave.js");
+    module.exports = (globalRoot.jsfxr = factory(RIFFWAVE));
   } else {
-    root.jsfxr = factory(root.RIFFWAVE);
+    globalRoot.jsfxr = factory(globalRoot.RIFFWAVE);
   }
 }(this, function(RIFFWAVE) {
   // module code here....
diff --git a/node_modules/jsfxr/sfxr.mjs b/node_modules/jsfxr/sfxr.mjs
new file mode 100644
index 0000000..a54b0ed
--- /dev/null
+++ b/node_modules/jsfxr/sfxr.mjs
@@ -0,0 +1,18 @@
+// ESM wrapper for sfxr.js (jsfxr)
+// This file provides ES module exports while maintaining backwards compatibility
+// with CommonJS consumers who use the original .js file.
+
+// IMPORTANT: Import riffwave first and set up global BEFORE sfxr.js loads
+// sfxr.js's SoundEffect.generate() expects RIFFWAVE to be a global
+import RIFFWAVE from './riffwave.js';
+if (typeof globalThis !== 'undefined') globalThis.RIFFWAVE = RIFFWAVE;
+if (typeof window !== 'undefined') window.RIFFWAVE = RIFFWAVE;
+
+// Now import sfxr.js - it can now find RIFFWAVE in the global scope
+import jsfxr from './sfxr.js';
+
+// Extract the sfxr API for convenience
+const sfxr = jsfxr.sfxr;
+
+export { jsfxr, sfxr };
+export default jsfxr;
